---
title: "liftover by realignment in R (liftoveR)"
author: "Eyal Ben-David"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{liftover by realignment in R (liftoveR)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Introduction

This vignette describes usage cases for the liftoveR package. The package includes three main modes - stringently aligning closely related sequences (using *Bowtie*), gapped alignment of related sequences (using *Rsubread*), aligning across species or highly divergent sequences (using *blastn*).

The following example dataset will highight each of these use cases.

## Aligning exon positions between two builds of Aspergillus Flavus

For many organisms lifting over a few coordinates from one genome build to another is a simple task, using the liftover tool available in the *UCSC genome browser*. Alas, we are interested in the pathogenic fungus *Aspergillus flavus*, for which no build exists in the *UCSC genome browser*. Luckily, we found a genome build in the *Ensembl* genome browser. To our dismay, our annotations are made with an old genome build and are incompatible with a newer build that is more used. In this example, we will download both the old and the new reference builds of *Asp. flavus*, as well as exon coordinates from the old build. We will align them to the new build, and compare the results to the coordinates found in the new annotations.

### Step 1: download old and new genome builds, and a list of coordinates from the ensembl genome database


Let's download both genomes and extract the fasta files. This can be done using the *gunzip* function from package *R.utils*.
```{r results="hide",warning=F,message=F}
require(R.utils)
download.file("ftp://ftp.ensemblgenomes.org/pub/fungi/release-34/fasta/aspergillus_flavus/dna/Aspergillus_flavus.JCVI-afl1-v2.0.dna.toplevel.fa.gz","aspFlavusNew.fa.gz")
download.file("ftp://ftp.ensemblgenomes.org/pub/fungi/release-3/fasta/aspergillus_flavus/dna/Aspergillus_flavus.CADRE.55.dna.toplevel.fa.gz","aspFlavusOld.fa.gz")
gunzip("aspFlavusOld.fa.gz")
gunzip("aspFlavusNew.fa.gz")
```

Let's do the same for gene annotations from both builds. The old build we will use for liftover, the new build for validation.

```{r results="hide",warning=F,message=F}
download.file("ftp://ftp.ensemblgenomes.org/pub/fungi/release-3/gtf/aspergillus_flavus/Aspergillus_flavus.CADRE.55.gtf.gz", "aspFlavusOld.gtf.gz")
download.file("ftp://ftp.ensemblgenomes.org/pub/fungi/release-34/gtf/aspergillus_flavus/Aspergillus_flavus.JCVI-afl1-v2.0.34.gtf.gz","aspFlavusNew.gtf.gz")
gunzip("aspFlavusOld.gtf.gz")
gunzip("aspFlavusNew.gtf.gz")
```

## Step 2: Read in coordinates and match the old annotations with the new ones

We will now read in the coordinates of all exons, for the old and the new build. In practice, we will only have one coordinate list, since we're aligning the exons to the new build. However, for our example, we want to be able to validate our results using the new annotations that we already know. Let's read in the gtf file. We will acquire the gene names and the exon numbers, and paste them together to create a unique identifier for each exon. This will be done using the *stringr* package. 

```{r results="hide",warning=F,message=F}
require(stringr)
genesOldCoords = read.delim("aspFlavusOld.gtf",comment.char =  "#",header = F,as.is = T)
genesOldCoords = genesOldCoords[genesOldCoords[,3]=="exon",]
```
```{r}
head(genesOldCoords)
```

We need to take the 9th column, and extract the gene name and the exon number. This requires some acrobatics due to the awkward formatting of *gtf* files. **warning: ugly code ahead**.
```{r results="hide",warning=F,message=F}
geneNamesOld = str_replace_all(str_extract(genesOldCoords[,9],"gene_name+.[A-Z,a-z,0-9,_]*"),"gene_name ","")
exonNumberOld = str_replace_all(str_extract(genesOldCoords[,9],"exon_number+.[0-9]*"),"exon_number ","")
exonNameAndNumberOld = paste(geneNamesOld,exonNumberOld,sep="_")
```

Repeat for the new annotations, those will only be used for validation.
```{r}
genesNewCoords = read.delim("aspFlavusNew.gtf",comment.char =  "#",header = F,as.is = T)
genesNewCoords = genesNewCoords[genesNewCoords[,3]=="exon",]
geneNamesNew = str_replace_all(str_extract(genesNewCoords[,9],"gene_id+.[A-Z,a-z,0-9,_]*"),"gene_id ","")
exonNumberNew = str_replace_all(str_extract(genesNewCoords[,9],"exon_number+.[0-9]*"),"exon_number ","")
exonNameAndNumberNew = paste(geneNamesNew,exonNumberNew,sep="_")
```

We can now use this identifier to exclude from the list exons that don't exist in both annotations, since we wouldn't be able to validate those. 

```{r results="hide",warning=F,message=F}
exonsInBoth = intersect(exonNameAndNumberNew,exonNameAndNumberOld)
genesOldCoordsFinal = genesOldCoords[match(exonsInBoth,exonNameAndNumberOld),]
genesNewCoordsFinal = genesNewCoords[match(exonsInBoth,exonNameAndNumberNew),]
```

## Step 3: liftoveR with Rbowtie


We are now ready to align. Let's align using *RBowtie*. Note that *RBowtie* doesn't allow any gaps in the alignment. This is useful if you'd like to restrict the alignment to highly similar regions between the genome builds, and are more concerned with errors than with losing some regions. Also, it is useful if you're using Windows, since it's your only choice at this point.

```{r message=F,warning=F}
require(liftoveR)
genesOldInNew = liftover(chrom = genesOldCoordsFinal[,1],
         start = genesOldCoordsFinal[,4],
         end = genesOldCoordsFinal[,5],
         originalBuild = "aspFlavusOld.fa",
         newBuild = "aspFlavusNew.fa",
         tmpdir = getwd(),
         maxMismatches = 5,
         aligner="Rbowtie")
```

The command includes basic elements that are universal to running *liftover*:

* chrom: a vector of chromosome names
* start: a vector of start positions
* end: a vector of end positions
* originalBuild: a fasta file from which the sequences will be extracted
* newBuild: a fasta file of the new build to align to
* aligner: the choice of the aligner to use (Rbowtie,Rsubread or blastn)

One thing you can notice is that liftoveR automatically split the regions to allow a maximum length of 500. This is controlled by the parameter *maxAllowedLength* that defaults to 500, and is important especially when using the short read aligners (*Rbowtie*, *Rsubread*) as they could fail when aligning long sequences. *liftover* automatically splits the reads, aligns, and then patches everything back together to get the start and end positions. Only regions in which all split reads are aligned are returned.

liftover also knows to generate index files automatically for the alignment. These will be generated in the same directory as the genome sequences, **and will not be removed automatically**. Also, in this example, we use the current working directory as the temporary directory. liftover generates input files for alignment from the sequence in the regions, and output bam files are also generated. The default behavior is to use the R temporary directory, so the user doesn't have to worry about that.
We've also set maxMismatches to be 5. This parameter is used differentialy depending on the aligner:

* Rbowtie - the number of mismatches, as defined by the NM tag in the SAM file generated in the alignment.
* Rsubread - the maximum number of mismatches allowed for alignment (defined by maxMismatches parameter of Rsubread)
* blastn - **It currently does absolutely nothing in blastn**, since the purpose is to align distantly related features. Alignment parameters for blastn can be provided manually to the function (see the help for *liftover*)

liftover identifies the new regions based on the alignment, and returns everything in a data frame.

```{r}
head(genesOldInNew)
```
The data frame includes the original coordinates and the new coordinates. The order of the table is the same as the inoput, and regions which were not aligned will have NA in the appropriate fields.


```{r}
sum(is.na(genesOldInNew$chrom))
```

Let's examine what percent of the exons did we successfuly map

```{r}
sum(genesOldInNew$chrom==genesNewCoords$V1 &genesOldInNew$start==genesNewCoords$V4 & genesOldInNew$end==genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100
```

How about errors, how many do we have?
```{r}
sum(genesOldInNew$chrom!=genesNewCoords$V1 |genesOldInNew$start!=genesNewCoords$V4 & genesOldInNew$end!=genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100
```

So in total, we are missing 126 exons, but we managed to map all the rest, with less than 1% error. Failing to align could be a result indels, which RBowtie just can't handle, multiple mismatches, or even genes which are genuinely omitted from the new build.

## Step 4: liftoveR with Rsubread

Let's try again to liftover the regions, this time with Rsubread. Unfortunately, from this point onwards, it's linux and mac only. This is due to the support of the aligners themselves.


As you can see, we change one parameter, and the function will do the rest.

```{r results="hide",warning=F,message=F}
genesOldInNew = liftover(chrom = genesOldCoordsFinal[,1],
         start = genesOldCoordsFinal[,4],
         end = genesOldCoordsFinal[,5],
         originalBuild = "aspFlavusOld.fa",
         newBuild = "aspFlavusNew.fa",
         tmpdir=getwd(),
         maxMismatches = 5,
         aligner="Rsubread")
```

```{r}
head(genesOldInNew)
```

Let's repeat our simple tests

```{r}
sum(is.na(genesOldInNew$chrom))
```


```{r}
sum(genesOldInNew$chrom==genesNewCoords$V1 &genesOldInNew$start==genesNewCoords$V4 & genesOldInNew$end==genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100
```

```{r}
sum(genesOldInNew$chrom!=genesNewCoords$V1 |genesOldInNew$start!=genesNewCoords$V4 & genesOldInNew$end!=genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100
```

So we fared a bit better, only missing 46 exons, and aligning the rest. We pay for it with a tiny increase in the number of false alignments.
Playing with the alignment parameters we can try to resolve this further. One thing we can do is take a larger region for alignment. This is done with the *lengthSides* argument that controls how much flanking sequence is taken. Also, we can allow more differences using the *maxMismatches* parameter.

```{r results="hide",warning=F,message=F}
genesOldInNew = liftover(chrom = genesOldCoordsFinal[,1],
         start = genesOldCoordsFinal[,4],
         end = genesOldCoordsFinal[,5],
         originalBuild = "aspFlavusOld.fa",
         newBuild = "aspFlavusNew.fa",
         tmpdir=getwd(),
         lengthSides = 100,
         maxMismatches = 30,
         aligner="Rsubread")
```

```{r}
sum(is.na(genesOldInNew$chrom))
```


```{r}
sum(genesOldInNew$chrom==genesNewCoords$V1 &genesOldInNew$start==genesNewCoords$V4 & genesOldInNew$end==genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100
```

```{r}
sum(genesOldInNew$chrom!=genesNewCoords$V1 |genesOldInNew$start!=genesNewCoords$V4 & genesOldInNew$end!=genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100

```

So it becomes a bit better, and the number of false positives doesn't change. Another consideration is that there could be a reason regions don't align, such as being highly repetitive. In such cases, we might not be able to resolve the location with short read realignment.

## Step 5: liftoveR with blastn

Finally, let's repeat the same analysis with blastn. First thing we need to do it register the blast binaries, as they're not currently packaged with *liftoveR*. **Important Note**: currently, *liftoveR* supports only the *blast+ build 2.2.31+*. This is because it requires the SAM output, and the implementation of the SAM output changes with each version of *blast+*. That version is available to download [here](ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/2.2.31/) We specifiy the path to the *blastn* and *makeblastdb* executables using the function *registerBlast*. We also need to specify a path to *samtools*, which will be used to process the SAM output from *blastn*.
```{r}
registerBlast("/usr/bin/blastn","/usr/bin/makeblastdb","/usr/bin/samtools")
```

Now lets run the alignment, this time with *blastn*. This should take somewhat longer, and multithreading is not currently supported, although again you can enable it by customizing the blastn arguments (see *liftover* help documentation).

```{r}
genesOldInNew = liftover(chrom = genesOldCoordsFinal[,1],
         start = genesOldCoordsFinal[,4],
         end = genesOldCoordsFinal[,5],
         originalBuild = "aspFlavusOld.fa",
         newBuild = "aspFlavusNew.fa",
         tmpdir=getwd(),
         aligner="blastn")
```


```{r}
sum(is.na(genesOldInNew$chrom))
```


```{r}
sum(genesOldInNew$chrom==genesNewCoords$V1 &genesOldInNew$start==genesNewCoords$V4 & genesOldInNew$end==genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100
```

```{r}
sum(genesOldInNew$chrom!=genesNewCoords$V1 |genesOldInNew$start!=genesNewCoords$V4 & genesOldInNew$end!=genesNewCoords$V5,na.rm = T) / nrow(genesOldInNew) * 100
```
We are able to get putatively more alignments, but be careful, our error rate also goes up! blast is highly flexible and can align more distantly related sequences, which can result in erroneous alignments.


Let's get rid of all the temporary files created for this run. Since running the package requires generating indices for alignment, it is recommended to run in a new directory, to be able to clean up afterwards.
```{r results="hide",warning=F,message=F}
removeDirectory("aspFlavusNew.fa.Rbowtie",recursive = T)
tmpdir = dir(pattern="Rtmp")
removeDirectory(tmpdir,recursive = T)
file.remove(dir(pattern="aspFlavus"))
file.remove(dir(pattern="QuasR"))
file.remove(dir(pattern="liftOverInput"))
file.remove(dir(pattern="blast"))
```
